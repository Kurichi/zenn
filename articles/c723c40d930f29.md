---
title: "\"æœ¬å½“ã«\"ã‚¼ãƒ­ã‹ã‚‰ä½œã‚‹Deep Learning"
emoji: "ğŸ”–"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["æ©Ÿæ¢°å­¦ç¿’", "cpp"]
published: false
---
# ã¯ã˜ã‚ã«
ã“ã®è¨˜äº‹ã¯ç­†è€…ãŒDeep Learningã®ç†è§£ã®ãŸã‚ã€C++ã‚’ç”¨ã„ã¦ã‚¼ãƒ­ã‹ã‚‰Deep Learningã‚’å®Ÿè£…ã—ã¦ã¿ã‚‹ã¨ã„ã†ã‚‚ã®ã§ã™ã€‚
ã‚¿ã‚¤ãƒˆãƒ«ã‹ã‚‰ã‚‚ã‚ã‹ã‚‹é€šã‚Šã€OREILLYå‡ºç‰ˆã®ã€Œ[ã‚¼ãƒ­ã‹ã‚‰ä½œã‚‹Deep Learning](https://www.oreilly.co.jp/books/9784873117584/)ã€(ä»¥ä¸‹ï¼šåŸè‘—ï¼‰ã‚’å…ƒã«é€²ã‚ã¦ã„ãã¾ã™ã€‚
æœ¬è¨˜äº‹ã§ã¯åŸè‘—ã®ç¬¬3ç« ã‹ã‚‰é€²ã‚ã¦ã„ãã¾ã™ã€‚

ã¾ãŸã€Githubã«ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã‚‚ã‚ã’ã¦ã„ã‚‹ã®ã§è‰¯ã‹ã£ãŸã‚‰å‚ç…§ã—ã¦ãã ã•ã„ã€‚
[Github](https://github.com/Kurichi/DeepLearning-Zero)

### ç’°å¢ƒ
OS : Ubuntu20.04 on WSL2
ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© : x86_64-linux-gnu
GCC ãƒãƒ¼ã‚¸ãƒ§ãƒ³ : gcc 9.4.0
C++ ãƒãƒ¼ã‚¸ãƒ§ãƒ³ : c++20

### ãƒ¬ã‚®ãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
åŸºæœ¬çš„ã«æ¨™æº–ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ã¿ã‹ã‚‰å®Ÿè£…ã—ã¾ã™ã€‚
ä¾‹å¤–ã¨ã—ã¦ä»¥ä¸‹ã®2ã¤ã¯ä½¿ã„ã¾ã™ã€‚
- boost
- [matplotlib-cpp](https://github.com/lava/matplotlib-cpp)


### æ³¨æ„
ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã®è§£èª¬ã‚’é™¤ãã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ§‹é€ ãã®ã‚‚ã®ã®è§£èª¬ãªã©ã¯åŸºæœ¬çš„ã«è¡Œã„ã¾ã›ã‚“ã€‚
ã¾ãŸã€ç­†è€…ã¯C++åˆå¿ƒè€…ã§ã‚ã‚Šã€å†—é•·ãªæ›¸ãæ–¹ã‚„éæ¨å¥¨ãªæ›¸ãæ–¹ã‚’ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
ãã®å ´åˆã¯æŒ‡æ‘˜ã—ã¦ã„ãŸã ã‘ã‚‹ã¨åŠ©ã‹ã‚Šã¾ã™ã€‚

# matplotlib-cppã®è¨­å®š
ã‚°ãƒ©ãƒ•ã‚’æç”»ã™ã‚‹ãŸã‚ã«matplotlib-cppãŒã‚ã‚‹ã¨ä¾¿åˆ©ãªã®ã§å…¥ã‚Œã¾ã™ã€‚
ä»¥ä¸‹ã®ã‚³ãƒãƒ³ãƒ‰ã§å–ã£ã¦ãã¦ãã ã•ã„
```bash
wget https://github.com/lava/matplotlib-cpp/matplotlibcpp.h
```
CMakeã‚’ä½¿ã†ã®ã§ãªã„å ´åˆã¯å…¥ã‚Œã¦ãŠã„ã¦ãã ã•ã„ã€‚
CMakeLists.txtã¯Githubã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

# ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
## æ´»æ€§åŒ–é–¢æ•°
åŸè‘—ã§ã¯æ´»æ€§åŒ–é–¢æ•°ã¨ã—ã¦ã€ã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°ã€ã‚·ã‚°ãƒ¢ã‚¤ãƒ‰é–¢æ•°ã€ReLUé–¢æ•°ãŒå®Ÿè£…ã•ã‚Œã¦ã„ã¾ã™ã€‚
ã“ã“ã§ã‚‚ãã‚Œã«å€£ã£ã¦3ã¤ã®é–¢æ•°ã‚’å®Ÿè£…ã—ã¦ã¿ã¾ã™ã€‚
ã“ã“ã§ç´¹ä»‹ã™ã‚‹3ã¤ã®æ´»æ€§åŒ–é–¢æ•°ã¯å˜ç´”ãªã®ã§ç°¡å˜ã«å®Ÿè£…ã§ãã¾ã™ã­ã€‚
### ã‚¹ãƒ†ãƒƒãƒ—é–¢æ•°
```cpp:ActivationFunction.hpp
namespace deepLearningZero {
template <typename T>
concept Number = std::integral<T> or std::floating_point<T>;

// Step function
template <Number N>
std::vector<N> step_function(const std::vector<N> &v) {
  std::vector<N> result = v;
  for (N &value : result) value = value > 0;
  return result;
}

}  // namespace deepLearningZero
```
```cpp:main.cpp
#include <iostream>

#include "Inc/matplotlibcpp.h"
#include "NeuralNetwork/ActivationFunction.hpp"
namespace dl = deepLearningZero;
namespace plt = matplotlibcpp;

int main() {
  std::vector<double> x(100);
  auto itr = x.begin();
  for (double v = -5; v < 5; v += 0.1) *(itr++) = v;

  auto y = dl::sigmoid(x);
  plt::plot(x, y);
  plt::show();
  return 0;
}
```
![](/images/Step_Function.png)

### ã‚·ã‚°ãƒ¢ã‚¤ãƒ‰é–¢æ•°
```cpp:ActivationFunction.hpp
// Sigmoid
template <Number N>
std::vector<double> sigmoid(const std::vector<N> &v) {
  std::vector<double> result = v;
  for (auto &value : result) value = 1 / (1 + exp(-value));
  return result;
}
```
```cpp:main.cpp
int main() {
  std::vector<double> x(100);
  auto itr = x.begin();
  for (double v = -5; v < 5; v += 0.1) *(itr++) = v;

  auto y = dl::sigmoid(x);
  plt::plot(x, y);
  plt::show();
  return 0;
}
```
![](/images/Sigmoid.png)

### ReLUé–¢æ•°
```cpp:ActivationFunction.hpp
template <Number N>
std::vector<N> ReLU(const std::vector<N> &v) {
  std::vector<N> result = v;
  for (auto &value : result) value = std::max((N)0, value);
  return result;
}
```
```cpp:main.cpp
int main() {
  std::vector<double> x(100);
  auto itr = x.begin();
  for (double v = -5; v < 5; v += 0.1) *(itr++) = v;

  auto y = dl::ReLU(x);
  plt::plot(x, y);
  plt::show();
  return 0;
}
```
![](/images/ReLU.png)

## ãƒ™ã‚¯ãƒˆãƒ«ç©
ãƒ™ã‚¯ãƒˆãƒ«ç©ã¯å¿…ãšã¨è¨€ã£ã¦ã„ã„ã»ã©ä½¿ã†ã®ã§ã“ã“ã§å®Ÿè£…ã—ã¦ãŠãã¾ã™ã€‚
```cpp:NumCpp.hpp
namespace numcpp {
template <typename T>
concept Number = std::integral<T> or std::floating_point<T>;

template <Number T>
std::vector<std::vector<T>> dot(const std::vector<std::vector<T>> &a,
                                const std::vector<std::vector<T>> &b) {
  const int high = a.size();
  const int common = b.size();
  const int width = b[0].size();
  std::vector<std::vector<T>> result(high, std::vector<T>(width, 0));
#pragma omp parallel for
  for (int i = 0; i < high; i++) {
    for (int j = 0; j < width; j++) {
      for (int k = 0; k < common; k++) {
        result[i][j] += a[i][k] * b[k][j];
      }
    }
  }

  return result;
}

}  // namespace numcpp
```
```cpp:main.cpp
int main() {
  std::vector<std::vector<int>> a({{0, 1}, {2, 3}, {4, 5}});
  std::vector<std::vector<int>> b({{0, 1, 2, 3}, {4, 5, 6, 7}});
  auto r = nc::dot(a, b);
  for (int i = 0; i < r.size(); i++) {
    for (int j = 0; j < r[i].size(); j++) std::cout << r[i][j] << " ";
    std::cout << "\n";
  }
  return 0;
}
```
```bash:å®Ÿè¡Œçµæœ
4 5 6 7
12 17 22 27
20 29 38 47
```
ã¡ã‚ƒã‚“ã¨è¨ˆç®—ã§ãã¾ã—ãŸã€‚
æ°—ä¼‘ã‚ç¨‹åº¦ã«OpenMPã§ä¸¦åˆ—åŒ–ã—ã¦ã¿ã¾ã—ãŸã€‚
ã—ã‹ã—1000x1000ã®ãƒ™ã‚¯ãƒˆãƒ«åŒå£«ã®ç©ãªã©ã¨ãªã‚‹ã¨éå¸¸ã«æ™‚é–“ãŒã‹ã‹ã‚Šã¾ã™ã€‚ãŠãã‚‰ãæœ€é©åŒ–ã™ã‚‹ã“ã¨ã§ä½•å€ã‚‚é€Ÿããªã‚Šã¾ã™ãŒã€æœ¬ç­‹ã¨é›¢ã‚Œã‚‹ã®ã§ä¸€æ—¦ã“ã®ã¾ã¾é€²ã¿ã¾ã™ã€‚

## 3å±¤ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯
### å„å±¤ã«ãŠã‘ã‚‹ä¿¡å·ä¼é”ã®å®Ÿè£…
å…¥åŠ›ã€é‡ã¿ã€ãƒã‚¤ã‚¢ã‚¹ã‚’ãã‚Œãã‚Œå®šç¾©ã—ã¦è¨ˆç®—ã—ã¦ã¿ã¾ã™ã€‚
C++ã«ã¯è¡Œåˆ—ã‚’æ‰±ã†ãƒ‡ãƒ¼ã‚¿å‹ãŒãªãï¼Œã•ã™ãŒã«æ‰±ã„ã«ãã„ã®ã§NdArrayã‚¯ãƒ©ã‚¹ã‚’å®šç¾©ã—ã¾ã—ãŸã€‚
ã“ã“ã«è¼‰ã›ã‚‹ã¨é‚ªé­”ãªã®ã§èˆˆå‘³ã®ã‚ã‚‹æ–¹ã¯Githubã‚’è¦‹ã¦ãã ã•ã„ã€‚

è¡Œåˆ—ç©ã€å››å‰‡æ¼”ç®—ç¨‹åº¦ã®æ©Ÿèƒ½ã—ã‹æŒãŸã›ã¦ã„ã¾ã›ã‚“ã€‚

åŸºæœ¬çš„ã«åŸè‘—ã¨åŒæ§˜ã®æ›¸ãæ–¹ãŒã§ãã‚‹ã‚ˆã†ã«è¨­è¨ˆã—ãŸã®ã§ã‚ã¾ã‚Šè¦‹ãŸç›®ãŒå¤‰ã‚ã‚‰ãªã„ã¨æ€ã„ã¾ã™ã€‚
è¡Œåˆ—ç©ã¯dotã§ã‚‚ã‚ˆã‹ã£ãŸã®ã§ã™ãŒã‚ˆã‚Šç›´æ„Ÿçš„ã«æ‰±ãˆã‚‹ã‚ˆã†ã«ã€ä½¿ã‚ãªã„ã§ã‚ã‚ã†æ¼”ç®—å­ '&'ã‚’ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã—ã¾ã—ãŸã€‚
ã‚½ãƒ¼ã‚¹ã‚³ãƒ¼ãƒ‰ã€çµæœã¯ä»¥ä¸‹ã®é€šã‚Šã§ã™ã€‚

```cpp:main.cpp
namespace myDeepLearning {
using network_t = std::unordered_map<std::string, nc::NdArray<double>>;

network_t init_network() {
  network_t result;
  // Weight
  result["W1"] = {{0.1, 0.3, 0.5}, {0.2, 0.4, 0.6}};
  result["W2"] = {{0.1, 0.4}, {0.2, 0.5}, {0.3, 0.6}};
  result["W3"] = {{0.1, 0.3}, {0.2, 0.4}};

  // Bias
  result["B1"] = {{0.1, 0.2, 0.3}};
  result["B2"] = {{0.1, 0.2}};
  result["B3"] = {{0.1, 0.2}};

  return result;
}

nc::NdArray<double> forward(network_t &network, nc::NdArray<double> &x) {
  auto &&a1 = (x & network["W1"]) + network["B1"];
  auto &&z1 = dl::sigmoid(a1);

  auto &&a2 = (z1 & network["W2"]) + network["B2"];
  auto &&z2 = dl::sigmoid(a2);

  auto &&a3 = (z2 & network["W3"]) + network["B3"];
  return a3;
}

}  // namespace myDeepLearning

namespace mdl = myDeepLearning;

int main() {
  auto &&network = mdl::init_network();
  nc::NdArray x(1, 2);
  x[0] = 1.0;
  x[1] = 0.5;
  auto &&y = mdl::forward(network, x);
  std::cout << y << std::endl;

  return 0;
}
```
```bash
$ ./DLZero
0.316827 0.696279
```

ç„¡äº‹ã€åŸè‘—ã¨åŒã˜çµæœã‚’å¾—ã‚‹ã“ã¨ãŒã§ãã¾ã—ãŸã€‚